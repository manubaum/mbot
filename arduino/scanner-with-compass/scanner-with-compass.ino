// generated by mBlock5 for mBot
// codes make you happy

#include <MeMCore.h>
#include <Arduino.h>
#include <Wire.h>
#include <SoftwareSerial.h>
#include "math.h"
#include <MeCompass.h>


/*
   Two modes:   Automatic
                Manual

   Automatic mode:
    - rotate
      - select direction / speed
      - find direction with nothing in line
      - or
      - detect that no rotation happening
   - go straight
      - select speed
      - stop if:
        - loosing contact with the floor
        - obstacle found

*/

/*
  Hardware:
  Port1         Thermometer
  Port2         Linesensor
  Port3         Ultrasonic
  Port4         4 digit 7-segment display
*/

// Port 1 Compass
MeCompass Compass(PORT_1);

// Port 2 Line Follower
MeLineFollower linefollower_2(PORT_2);

//Port 3
MeUltrasonicSensor ultrasonic(PORT_3);

// Port 4
Me7SegmentDisplay display(PORT_4);

// built in rgb led
MeRGBLed rgbled(7, 2);

// makeblock robot motors
MeDCMotor motor_left(9);
MeDCMotor motor_right(10);

//infrared remote
MeIR ir;

void setup() {

  // RJ25 adapter
  Serial.begin(9600);


  display.init();
  display.set(BRIGHTNESS_7);

  rgbled.show();

  Compass.begin();

  ir.begin();

  randomSeed(analogRead(0));

}


unsigned int globalPreviousDistance;
unsigned int globalPreviousAngle;
unsigned int globalPreviousTime;

long CRITICAL_DISTANCE = 50;

char mode = 'A';

char rotate_mode = 'G';

unsigned long lastTimeProcessed;

char buffer[50];


void loop() {

  //_delay(0.5);

  //Serial.print("Mode: ");
  //Serial.println(mode);

  switch (mode) {
    case 'A':
      switch (rotate_mode) {
        case 'R':
          // select direction / speed
          rotate();
          rotate_mode = 'D';
          break;
        case 'D':
          // maximize distance
          // detect that no rotation happening
          findGoodDirectionDuringRotation();
          break;
        case 'G':
          // select direction / speed
          goStraight();
          rotate_mode = 'P';
          break;
        case 'P':
          // make sure to not bump anywhere
          preventCollision();
          break;
      }

      break;
    case 'M':

      break;

    case 'B':
      // blocked
      stopMovingAndDislpayBlocked();
      mode = 'X';

      break;
    case 'X':
      // blocked
      lookForRestart();
      break;
  }

}

void lookForRestart() {

  /*
  if ((analogRead(A7) > 10 ? 0 : 1)) {
    mode = 'A';
    rotate_mode = 'R';
    return;
  }*/

  unsigned int currentDistance = ultrasonic.distanceCm();

  bool surfaceContact = hasSurfaceContact();

  if (surfaceContact && currentDistance > 40) {
    // blocked?
    mode = 'A';
    rotate_mode = 'G';
    display.clearDisplay();
  }

}

void preventCollision() {

  unsigned int currentDistance = ultrasonic.distanceCm();
  bool surfaceContact = hasSurfaceContact();

  sprintf(buffer, "-> preventCollision (%dcm, %d)", currentDistance, surfaceContact);
  Serial.println(buffer);

  if (!surfaceContact) {
    // blocked?
    mode = 'B';
    display.display(1);
    return;
  }

  // spatial
  if (currentDistance < 30 || currentDistance >= 398) {
    // we seem to see an obstacle: start rotating
    Serial.println("-> obstacle detected. Going to rotate");
    rotate_mode = 'R';
    return;
  }
}

void goStraight() {
  Serial.println("-> goStraight");

  long leftOrRight = randomlySelectLeftOrRight();
  int speed = 255;//randomlySelectSpeed();


  rgbled.setColor(0, 255, 255, 255);
  rgbled.show();

  // go straight
  move(1, speed);

}

void findGoodDirectionDuringRotation() {



  Serial.println("-> findGoodDirectionDuringRotation");

  unsigned int currentDistance = ultrasonic.distanceCm();
  unsigned int currentAngle = getAngle();
  unsigned int currentTime = millis();

  unsigned int previousDistance = globalPreviousDistance;
  unsigned int previousAngle =  globalPreviousAngle;
  unsigned int previousTime =  globalPreviousTime;


  if (!hasSurfaceContact()) {
    // blocked?
    Serial.println("-> lost surface contact: blocking");
    mode = 'B';
    display.display(1);
    return;
  }

  // temporal
  if (previousTime + 500 > currentTime) {
    Serial.println("-> too early. skipping");
    //Serial.println(currentTime);
    //Serial.println(previousTime);

    return;
  }

  // rotational
  if (abs(previousAngle - currentAngle) < 5) {
    // blocked?

    sprintf(buffer, "(previousAngle: %d, currentAngle: %d)", previousAngle, currentAngle);
    Serial.println(buffer);

    Serial.println("-> no progress in rotation: blocking");
    mode = 'B';
    display.display(2);
    return;
  }

  globalPreviousDistance = currentDistance;
  globalPreviousAngle = currentAngle;
  globalPreviousTime = currentTime;

  // spatial
  if (currentDistance < 30) {
    // we seem to see an obstacle: keep rotating
    Serial.println("-> keep rotating");

  }
  else{
    // we seem to have no obstacle ahead
    Serial.println("-> go straight");
    rotate_mode = 'G';
 }

}

void rotate() {
  Serial.println("-> rotate");

  long leftOrRight = randomlySelectLeftOrRight();
  int speed = 180;

  rgbled.setColor(0, 0, 0, 255);
  rgbled.show();

  // rotate
  move(leftOrRight, speed);

}

void stopMovingAndDislpayBlocked() {
  Serial.println("-> stopMovingAndDislpayBlocked");
  move(0, 0);
  rgbled.setColor(0, 255, 0, 0);
  rgbled.show();
}

int randomlySelectSpeed() {
  return random(50, 50) / 100.0 * 255;
}

long randomlySelectLeftOrRight() {
  return ((uint16_t) ultrasonic.distanceCm() % 2) == 1 ? 3 : 4;
}

// https://www.mblock.cc/example/value-of-the-line-follower-sensor/
bool hasSurfaceContact() {
  return linefollower_2.readSensors() != 0;
}

unsigned int getAngle() {
  int16_t head_X, head_Y, head_Z;
  double angle = 0;

  head_X = Compass.getHeadingX();
  head_Y = Compass.getHeadingY();
  head_Z = Compass.getHeadingZ();
  angle = Compass.getAngle();

  return (unsigned int) angle;
}


void move(int direction, int speed) {
  int leftSpeed = 0;
  int rightSpeed = 0;
  if (direction == 1) {
    leftSpeed = speed;
    rightSpeed = speed;
  } else if (direction == 2) {
    leftSpeed = -speed;
    rightSpeed = -speed;
  } else if (direction == 3) {
    leftSpeed = -speed;
    rightSpeed = speed;
  } else if (direction == 4) {
    leftSpeed = speed;
    rightSpeed = -speed;
  }
  motor_left.run((9) == M1 ? -(leftSpeed) : (leftSpeed));
  motor_right.run((10) == M1 ? -(rightSpeed) : (rightSpeed));
}

void _delay(float seconds) {
  long endTime = millis() + seconds * 1000;
  while (millis() < endTime) _loop();
}

void _loop() {}
